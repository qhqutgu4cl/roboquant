package org.roboquant.strategies

import org.roboquant.brokers.Account
import org.roboquant.feeds.Event
import org.roboquant.orders.Instruction

/**
 *
 * @property signalConverter SignalConverter
 * @constructor
 */
abstract class SignalStrategy(var signalConverter: SignalConverter = FlexConverter()) : Strategy {

    override fun create(event: Event, account: Account): List<Instruction> {
        val signals = generate(event)
        return signalConverter.convert(signals, account, event)
    }

    abstract fun generate(event: Event): List<Signal>

}


/**
 * A SignalConverter is responsible for creating [Orders][Instruction] based on the [Signals][Signal] generated by a
 * strategy. Besides, turning signals into orders, a signalConverter should also take care of:
 *
 * * signal conflicts: for example, receive both a SELL and BUY signal for the same asset at the same time
 * * order management: for example, how to deal with open orders
 * * portfolio construction: for example, re-balancing of the portfolio based on some pre-defined risk parameters
 * * risk management: for example, limit exposure to certain sectors
 *
 * Please note that a broker which receives the orders that a SignalConverter created, might not support all the different
 * order types.
 */
fun interface SignalConverter  {

    /**
     * Convert the received [signals] into orders, based also on the latest state of the [account] and
     * the last known [event].
     *
     * @param signals the list of [signals][Signal] generated by the strategy
     * @param account the account state at a point in time
     * @param event the market data
     * @return a list of orders
     */
    fun convert(signals: List<Signal>, account: Account, event: Event): List<Instruction>


}
