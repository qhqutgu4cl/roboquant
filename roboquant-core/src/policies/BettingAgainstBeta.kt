package org.roboquant.policies

import org.apache.commons.math3.stat.correlation.Covariance
import org.roboquant.Phase
import org.roboquant.brokers.Account
import org.roboquant.brokers.Portfolio
import org.roboquant.brokers.Position
import org.roboquant.common.Asset
import org.roboquant.feeds.Event
import org.roboquant.orders.MarketOrder
import org.roboquant.orders.Order
import org.roboquant.strategies.Signal
import org.roboquant.strategies.utils.AssetReturns
import java.time.Instant
import java.time.temporal.ChronoUnit
import kotlin.math.min

/**
 * Betting against Beta (BaB) is actually a strategy based on the premise that high beta stocks might be overvalued and
 * low beta stocks undervalued. So this strategy goes long on low beta stocks and short on high beta stocks.
 *
 * It will then hold these positions for a number of days before re-evaluating the strategy. After re-evaluation, the
 * strategy will then generate the market orders required to achieve the desired new portfolio composition (re-balancing).
 *
 * Since this strategy controls the complete [Portfolio] and not just generates signals, it is implemented as a [Policy].
 *
 * > Betting against Beta was first described by Andrea Frazzinia and Lasse Heje Pedersen in Journal of Financial Economics
 *
 *
 * @constructor Create empty Betting against beta
 */
open class BettingAgainstBeta(
    assets: Collection<Asset>,
    val market: Asset,
    private val holdingPeriodDays: Int = 20,
    private val maxAssetsInPortfolio: Int = 20,
    windowSize: Int = 120,
    private val sizer: Sizer = FixedValueSizer()
) : BasePolicy() {

    private var rebalanceDate = Instant.MIN

    val buffers = AssetReturns(assets, windowSize, Double.NaN)

    init {
        require(market in assets) { "The selected market asset $market also has to be part of all assets" }
    }

    /**
     * Calculate the betas for the assets. If a beta cannot be calculated, for example due to missing data,
     * it will not be included in the returned result.
     *
     * @return
     */
    private fun calculateBetas(): List<Pair<Asset, Double>> {
        val betas = mutableListOf<Pair<Asset, Double>>()
        val x = buffers.toDoubleArray(market)
        buffers.assets.forEach { asset ->
            if (asset != market) {
                val y = buffers.toDoubleArray(asset)
                val beta = Covariance().covariance(x, y)
                if (!beta.isNaN()) betas.add(Pair(asset, beta))
            }
        }
        // Sort the list by beta value, low to high
        betas.sortBy { it.second }
        return betas
    }

    /**
     * Re-balance the portfolio based on the calculated betas.
     *
     * @param betas
     * @param account
     * @return
     */
    private fun rebalance(betas: List<Pair<Asset, Double>>, account: Account, event: Event): List<Order> {
        // maximum number of short and long assets we want to have in portfolio
        val max = min(betas.size / 2, maxAssetsInPortfolio / 2)

        val targetPortfolio = Portfolio()

        // Generate the orders for a long position in assets with a low beta
        betas.subList(0, max).forEach {
            val holding = sizer.size(it.first, account, event)
            targetPortfolio.setPosition(Position(it.first, holding))
        }

        // Generate the orders for a short position in assets with a high beta
        betas.reversed().subList(0, max).forEach {
            val holding = sizer.size(it.first, account, event)
            targetPortfolio.setPosition(Position(it.first, -holding))
        }

        // Get the difference of target portfolio state and the current one
        val diff = account.portfolio.diff(targetPortfolio)

        // Transform difference into Market Orders
        return diff.map { getOrder(it.key, it.value, account, event) }
    }

    /**
     * Override this method if you want to override the default generation of MarketOrders with a different
     * order type like LimitOrders.
     */
    open fun getOrder(asset: Asset, quantity: Double, account: Account, event: Event): Order {
        return MarketOrder(asset, quantity)
    }


    /**
     * Create zero or more orders based on the received signals.
     *
     * @param signals
     * @param account the data at a point in time (as generated by the universe)
     * @return
     */
    override fun act(signals: List<Signal>, account: Account, event: Event): List<Order> {

        // First we update the buffers
        buffers.add(event)

        // Check if it is time to re-balance the portfolio
        if (event.now >= rebalanceDate && buffers.isAvailable()) {
            val betas = calculateBetas()

            // Update the re-balance date
            rebalanceDate = event.now.plus(holdingPeriodDays.toLong(), ChronoUnit.DAYS)
            return rebalance(betas, account, event)
        }
        return listOf()
    }

    /**
     * Clear any state before a new phase is started
     *
     * @param phase
     */
    override fun start(phase: Phase) {
        buffers.clear()
        rebalanceDate = Instant.MIN
    }

}